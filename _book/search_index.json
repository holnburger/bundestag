[
["index.html", "Geschlechterunterschiede im Deutschen Bundestag Kapitel 1 Einleitung", " Geschlechterunterschiede im Deutschen Bundestag Josef Holnburger und Gina-Gabriela Görner Kapitel 1 Einleitung Zusammen mit Gina-Gabriele Görner analysiere ich die Protokolle des Deutschen Bundestages auf mögliche Geschlechterunterschiede. Hierfür wollen wir die Anzahl aber auch Inhalte der Reden mehrer Wahlperioden des Bundestags untersuchen. Dieses Projekt wurde auch für die 4. International Conference on Computational Social Science eingereicht und wir dürfen es dort mit einem Plakat vorstellen. Wir orientieren uns vor allem an der Forschung von Bäck et al. (2014), welche das schwedische Parlament auf mögliche Geschlechterunterschiede und Diskriminierung hin untersucht haben. In dieser Studie wurden Unterschiede sowohl in der Anzahl als auch bezüglich des Inhalts der Reden festgestellt. Auuch im schwedischen Parlament sind Männer deutlich häufiger zu hören – obwohl es mit einem Frauenanteil von 40 Prozent die höchste Quote europäischer Parlamente aufweist (Bäck et al. 2014: 505). Männer sprechen in ihren Reden häufiger über hard topics, bei soft topics ist der Redeanteil hingegen ausgeglichen (ebd: 513ff.). Die Konstruktion der hard und soft topics geht dabei auf Wangnerud (2000) zurück und ist nicht unkritisch – hier werden durchaus Geschlechterstereotype aufrechterhalten oder gar reproduziert, indem “typische” Frauen und Männerthemen identifiziert werden. Wangnerud hat ihn ihrer Untersuchung die Mitglieder des schwedischen Riksdag bezüglich ihrer Aktivitäten befragt. Das Ergebnis von Bäck et al. (2014) ist deshalb auch nicht besonders überraschend – bestätigt es doch nur, dass die Fachpolitiker_innen häufiger über ihre Themen auch im Plenum reden. In dieser Arbeit soll anders vorgegangen werden. Die Inhalte der Reden im Bundestaug sollen ohne voherige Identifikation vermeintlicher Frauen- und Männerthemen untersucht werden. Hierbei nutzen wir die Möglichkeiten des Topic Modelling um zunächst generell Themen der Reden im Bundestags zu identifizieren und diese anschließend auf mögliche Geschlechterunterschiede untersuchen. Natürlich wollen auch wir die Unterschiedlichen Redeanteile untersuchen. Da ich den Prinzipien der Open Science sehr viel abgewinnen kann, soll die Erhebung und Auswertung möglichst transparent und nachvollziehbar dargestellt werden. Literatur- und Quellverzeichnis "],
["data-01.html", "Kapitel 2 Datenerhebung Teil 1 2.1 XML-Knoten und Attribute 2.2 Zwischenfazit", " Kapitel 2 Datenerhebung Teil 1 Die Reden im Deutschen Bundestag sind in den Protokollen dokumentiert und lassen sich online abrufen. Praktischerweise liegen die Daten seit der aktuellen Wahlerperiode auch im TEI-Format (Text Encoding Initiative) vor. Dies erleichtert die Analyse der Protkolle erheblich. Die Datenerhebung und Auswertung erfolgt mit der Programmiersprache R (R Core Team 2018) und der tidyverse Packetsammlung (Wickham 2017). Die Datenerhebung soll zunächst an einem Beispielprotokoll gezeigt werden – wir nutzen hierfür das Protokoll der 61. Sitzung des 19. Bundestages. Das Protokoll liegt dabei sowohl als PDF, als TXT und auch als XML-Datei vor. Letzeres wird für diese Arbeit herangezogen. Mit dem Packet xml2 (Wickham et al. 2018) kann das Protokoll ausgelesen und anschließend in ein passendes Format umgewandelt werden. Mit der Funktion read_html() wird das vollständige Protokoll in der Variable prot_file eingelesen. Die Umwandlung der einzelnen Knoten und Attribute des XML-Dokuments erfolgt mit dem rvest Packet (Wickham 2016). Da für diese Auswertung nur die Reden im Deutschen Bundestag herangezogen werden (und angehängte Dokumente sowie Anwesenheitslisten irrelevant sind), soll nur ein Teil des Protkolls untersucht werden. Mittels der Funktion xml_find_all(&quot;//rede&quot;) können alle Einträge unter dem Knoten “rede” herausgefiltert werden. library(tidyverse) library(xml2) library(rvest) prot_file &lt;- read_html(&quot;https://www.bundestag.de/blob/577958/b2d1fce9b7dec32a1403a2ec5f6bc58d/19061-data.xml&quot;) prot_overview &lt;- prot_file %&gt;% xml_find_all(&quot;//rede&quot;) Die Datei soll anschließend in einen Dataframe umgewandelt werden. Dies erleichtert die weitere Arbeit und im weiteren Verlauf können die Daten einfacher nach nach Geschlecht, Partei, Datum oder Wahlperiode gefiltert werden. Hierbei wird vor allem mit den Funktionen xml_node() und xml_attr() gearbeitet. Zum Verständnis bietet sich hier ein kleiner Diskurs an. 2.1 XML-Knoten und Attribute Nachdem die Datei eingelesen wurde, lohnt sich ein Blick auf die Rohdaten: &lt;rede id=&quot;ID196105400&quot;&gt; &lt;p klasse=&quot;redner&quot;&gt;&lt;redner id=&quot;11004826&quot;&gt;&lt;name&gt;&lt;vorname&gt;Siemtje&lt;/vorname&gt;&lt;nachname&gt;Möller&lt;/nachname&gt;&lt;fraktion&gt;SPD&lt;/fraktion&gt;&lt;/name&gt;&lt;/redner&gt;Siemtje Möller (SPD):&lt;/p&gt; &lt;p klasse=&quot;J_1&quot;&gt;Lieber Jürgen Trittin, Sie haben gerade eigentlich das wiederholt, was Sie schon in Ihrem Redebeitrag gesagt haben. Ich möchte dazu genau dasselbe sagen, was ich auch in der Debatte über Syrien und eine mögliche Beteiligung der Bundeswehr gesagt habe: Wir sind da noch nicht. Es gilt, alles zu tun, damit dieser Zustand nicht eintritt. Und genau das tut Heiko Maas.&lt;/p&gt; &lt;kommentar&gt;(Beifall bei der SPD)&lt;/kommentar&gt; &lt;/rede&gt; In diesem Beispiel wird das XML-Fragment in die Variable xml_example geladen und ausgewertet. Die Knoten eines XML-Documents werden durch &lt;&gt; und &lt;/&gt; eingefasst. Beispielsweise können die Knoten mit den Namen “Kommentar” folgendermaßen extrahiert werden: xml_example %&gt;% xml_nodes(&quot;kommentar&quot;) ## {xml_nodeset (1)} ## [1] &lt;kommentar&gt;(Beifall bei der SPD)&lt;/kommentar&gt; Bei der Ausgabe fällt jedoch auf, dass die Datei weiterhin eine XML-Datei bleibt und die Knoteninformationen ebenfalls extrahiert werden. Mittels der Funktion xml_text() kann das Ergebniss in einen in einen Character-String umwandelt werden. xml_example %&gt;% xml_nodes(&quot;kommentar&quot;) %&gt;% xml_text() ## [1] &quot;(Beifall bei der SPD)&quot; Die Ergebnisse werden in einer Liste zusammengefasst und können beispielsweise in einem Datenframe umgewandelt werden. Die Attribute eines Knotens finden sich in den Klammern nach dem Gleichheitszeichen: &lt;knotenname attribut=&quot;inhalt&quot;&gt;.... Die Werte eines Attributes (und auch den Attributnamen) können mit der Funktion xml_attr() extrahiert werden. xml_example %&gt;% xml_node(&quot;rede&quot;) %&gt;% xml_attr(&quot;id&quot;) ## [1] &quot;ID196105400&quot; Mit dieser kurzen Exkursion können wir nun eine Funktion bauen, welche auf die für uns relevanten Daten aus dem XML-Dokument extrahiert und anschließend in einen Datenframe umwandelt. get_overview_df &lt;- function(x){ rede_id &lt;- x %&gt;% xml_attr(&quot;id&quot;) redner_id &lt;- x %&gt;% xml_node(&quot;redner&quot;) %&gt;% xml_attr(&quot;id&quot;) redner_vorname &lt;- x %&gt;% xml_node(&quot;redner&quot;) %&gt;% xml_node(&quot;vorname&quot;) %&gt;% xml_text() redner_nachname &lt;- x %&gt;% xml_node(&quot;redner&quot;) %&gt;% xml_node(&quot;nachname&quot;) %&gt;% xml_text() redner_fraktion &lt;- x %&gt;% xml_node(&quot;redner&quot;) %&gt;% xml_node(&quot;fraktion&quot;) %&gt;% xml_text() redner_rolle &lt;- x %&gt;% xml_node(&quot;rolle_kurz&quot;) %&gt;% xml_text() data_frame(rede_id, redner_id, redner_vorname, redner_nachname, redner_fraktion, redner_rolle) } Wir können mit dieser Funktion nun die vorher eingelesen XML-Datei in einen Datenframe umwandeln und auswerten. overview_df &lt;- get_overview_df(prot_overview) overview_df ## # A tibble: 144 x 6 ## rede_id redner_id redner_vorname redner_nachname redner_fraktion ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 ID1961… 11003196 Andrea Nahles SPD ## 2 ID1961… 11004873 Ulrike Schielke-Ziesi… AfD ## 3 ID1961… 11002666 Hermann Gröhe CDU/CSU ## 4 ID1961… 11004179 Johannes Vogel FDP ## 5 ID1961… 11004012 Matthias W. Birkwald DIE LINKE ## 6 ID1961… 11003578 Markus Kurth BÜNDNIS 90/DIE… ## 7 ID1961… 11003142 Hubertus Heil &lt;NA&gt; ## 8 ID1961… 11004856 Jürgen Pohl AfD ## 9 ID1961… 11002812 Max Straubinger CDU/CSU ## 10 ID1961… 11004941 Gyde Jensen FDP ## # ... with 134 more rows, and 1 more variable: redner_rolle &lt;chr&gt; 2.2 Zwischenfazit Wir konnten mit wenigen Zeilen Code das XML-Format in einen Datenframe umwandeln, welcher uns die weitere Arbeit erheblich erleichter. So könnten wir sehr schnell sagen, wie viele Reden es von den einzelnen Fraktionen zur 61. Sitzung des 19. Bundestags gab: overview_df %&gt;% group_by(redner_fraktion) %&gt;% summarise(reden = n()) %&gt;% arrange(-reden) ## # A tibble: 8 x 2 ## redner_fraktion reden ## &lt;chr&gt; &lt;int&gt; ## 1 CDU/CSU 41 ## 2 SPD 27 ## 3 AfD 20 ## 4 BÜNDNIS 90/DIE GRÜNEN 16 ## 5 FDP 16 ## 6 DIE LINKE 15 ## 7 &lt;NA&gt; 6 ## 8 fraktionslos 3 Da NA Fraktionen sind dabei die Reden von Ministern und Gästen. Sie werden keiner Fraktion zugeordnet. Insgesamt gab es 144 Reden an diesem Tag. Uns interessieren natürlich nun nicht nur die Anzahl der Reden, sondern auch deren Inhalt. Wir untersuchen hierfür alle Knoten eine Ebene unter den “rede”-Knoten. prot_speeches &lt;- prot_file %&gt;% xml_find_all(&quot;//rede/*&quot;) Wir bauen wieder eine Funktion, um alle Inhalte der Reden zu extrahieren. Diese Funktion ist ein wenig komplexer, da sie unter anderem die Funktion map() aus dem purrr Packet nutzt (ebenfalls tidyverse) – für weitere Informationen über die Funktion map() bietet sich dieses Tutorial an. Außerdem müssen die Rohdaten etwas angepasst werden, da die Aussagen des Präsidiums sonst falsch zugeordnet werden. get_speeches_df &lt;- function(x){ raw &lt;- x rede &lt;- x %&gt;% xml_text() id &lt;- x %&gt;% xml_node(&quot;redner&quot;) %&gt;% xml_attr(&quot;id&quot;) vorname &lt;- x %&gt;% xml_node(&quot;vorname&quot;) %&gt;% xml_text() nachname &lt;- x %&gt;% xml_node(&quot;nachname&quot;) %&gt;% xml_text() fraktion &lt;- x %&gt;% xml_node(&quot;fraktion&quot;) %&gt;% xml_text() rolle &lt;- x %&gt;% xml_node(&quot;rolle_kurz&quot;) %&gt;% xml_text() typ &lt;- x %&gt;% xml_name() status &lt;- x %&gt;% xml_attr(&quot;klasse&quot;) data_frame(raw, rede, id, vorname, nachname, fraktion, rolle, typ, status) %&gt;% mutate(rede_id = map(raw, ~xml_parent(.) %&gt;% xml_attr(&quot;id&quot;)) %&gt;% as.character()) %&gt;% select(-raw) %&gt;% mutate(status = ifelse(typ == &quot;kommentar&quot;, typ, status)) %&gt;% mutate(status = ifelse(typ == &quot;name&quot;, &quot;präsidium&quot;, status)) %&gt;% mutate(fraktion = case_when( typ == &quot;name&quot; ~ &quot;präsidium&quot;, !is.na(rolle) ~ &quot;andere&quot;, TRUE ~ fraktion)) %&gt;% fill(id, vorname, nachname, fraktion) %&gt;% mutate(präsidium = ifelse(fraktion == &quot;präsidium&quot;, TRUE, FALSE)) %&gt;% mutate(fraktion = ifelse(fraktion == &quot;präsidium&quot;, NA, fraktion)) %&gt;% filter(!status %in% c(&quot;T_NaS&quot;, &quot;T_Beratung&quot;, &quot;T_fett&quot;, &quot;redner&quot;)) %&gt;% filter(!typ %in% c(&quot;a&quot;, &quot;fussnote&quot;, &quot;sup&quot;)) %&gt;% select(rede_id, rede, id, vorname, nachname, fraktion, präsidium, typ, status) } speeches_df &lt;- get_speeches_df(prot_speeches) Mittels dieses Datenframes ist es nun möglich, nur die Aussagen von beispielsweise Andrea Nahles zu untersuchen – ohne Unterbrechungen und Fragen von anderen Abgeordneten “mitzuschneiden” oder Aussagen des Präsidiums mitzunehmen. Hier ein Beispiel: speeches_df %&gt;% filter(typ != &quot;kommentar&quot;) %&gt;% filter(präsidium == FALSE) %&gt;% filter(id == &quot;11003196&quot;) %&gt;% pull(rede) %&gt;% cat(fill = TRUE) ## Herr Präsident! Meine lieben Kolleginnen und Kollegen! Auch in dieser Woche verabschieden SPD und CDU/CSU konkrete Gesetze, die für mehr Gerechtigkeit und für mehr Zusammenhalt in Deutschland sorgen werden. Wir erhöhen das Kindergeld um 10 Euro. Wir verabschieden eine Pflegereform, auf deren Grundlage deutlich mehr Pflegekräfte eingestellt werden und die Pflegekräfte insgesamt besser bezahlt werden. Wir schaffen Arbeitsplätze für Mitbürgerinnen und Mitbürger, die schon sehr lange arbeitslos sind. Und wir sichern die Rente auf dem jetzigen Niveau. Diese Regierung liefert. ## Mit der heutigen Rentenreform vollziehen wir einen grundsätzlichen Richtungswechsel. Die alte Rentenformel sah vor, dass die Rente geringer steigt als die Löhne. Die neue Rentenformel stellt sicher: Die Renten steigen wie die Löhne. ## Wir sichern damit ein Rentenniveau auf dem heutigen Level. Das ist wirklich eine sehr entscheidende Weichenstellung. Zusätzliche Vorsorge über Betriebsrenten oder privat ist eine gute Sache – wenn sie eben ergänzend gedacht ist, nicht ersetzend. Das ist der entscheidende Punkt für uns. ## Denn die gesetzliche Rentenversicherung ist und bleibt die zentrale Säule im deutschen Rentensystem. ## Die Rentenreform folgt einem einfachen Prinzip: Wer ein Leben lang arbeitet, der verdient auch einen anständigen Lebensabend, der verdient eine Rente, von der er auch leben kann. ## Ich betone: Ich benutze den Begriff „verdient“ bewusst. Denn die Rente ist kein Almosen, und sie ist auch kein Luxus. Die Rente ist der gesellschaftliche Lohn für ein Leben voller Arbeit. Für die Mehrheit der Bevölkerung ist übrigens die gesetzliche Rente ihr größtes Vermögen. Sie bleibt die sicherste Form der Altersversorgung. ## Uns ist die Stärkung der umlagefinanzierten Rente ja auch deswegen so wichtig, weil die Systeme, die vor allem auf private Absicherung ausgerichtet waren, letztendlich alle in der Finanzkrise deutlich gestrauchelt sind. Das ist ganz eindeutig der Fall gewesen. ## Im Gegensatz zu den privaten steht die gesetzliche Rente blendend da. Würde man aus Beiträgen und Rentenansprüchen in der gesetzlichen Rente die Rendite berechnen, ergäbe sich ein stabiler Ertrag von 2 bis 3 Prozent pro Jahr, verlässlich und frei von Schwankungen. Das ist auf dem Kapitalmarkt momentan nicht zu kriegen, um es sehr deutlich zu sagen. ## Die umlagefinanzierte Rente ist deswegen der kapitalgedeckten überlegen. ## Ich spreche jetzt in diesem Hohen Haus auch etwas aus, was vielleicht nicht alle gerne hören: Entweder wir sichern heute das Rentenniveau auf dem jetzigen Stand bis zum Jahr 2025 und nach dem Willen der SPD auch weiter darüber hinaus, ## oder wir lassen zu, dass die Renten immer weiter sinken und entwertet werden. ## Wenn wir das aber zulassen, muss die junge Generation einem solchen System irgendwann das Vertrauen entziehen. Denn warum sollte ausgerechnet die junge Generation jahrzehntelang Beiträge zahlen, wenn sie am Ende keine Sicherheit darüber hat, was sie rausbekommt? Das ist doch Unsinn. ## Deswegen ist aus meiner Sicht die Sicherung des Rentenniveaus in diesem System auch wichtig im Sinne der Generationengerechtigkeit. Ein garantiertes Rentenniveau schafft für die junge Generation nämlich die Sicherheit, dass sie sich eben am Ende auch auf dieses System der gesetzlichen Rentenversicherung verlassen kann. ## Jetzt sagen manche, das sei nicht finanzierbar. Das ist ein ziemlich scheinheiliges Argument. ## Denn niemand wird ja wohl bestreiten, dass das Geld für eine auskömmliche Rente im Jahre, sagen wir, 2040 auch immer irgendwo herkommen muss. Die einzige Frage ist doch: Was ist der beste und der gerechteste Weg, dies dann zu finanzieren? Soll die heutige Arbeitnehmergeneration sowohl die Renten von heute finanzieren und gleichzeitig privat noch die eigene Rente aufstocken? Damit würden viele Arbeitnehmerinnen und Arbeitnehmer komplett überfordert. Oder soll auch die heutige Arbeitnehmergeneration sich darauf verlassen können, dass auch sie im Alter eine von ihren Kindern und dann auch durch zusätzliche Steuermittel finanzierte Rente bekommt? Die Frage ist doch nicht, ob, sondern die Frage ist, wie wir die Renten und die Garantie eines Rentenniveaus in Zukunft finanzieren. Darüber lohnt sich jeder Streit; gar keine Frage. ## Das, was wir heute beschließen, ist finanziert. Bis 2025 ist das Rentenniveau klar gesichert. ## Wir steigen darüber hinaus in die Bildung einer Demografierücklage ein. ## Damit schaffen wir die Voraussetzung, um den Steueranteil zur Finanzierung der Rentenversicherung systematisch auf- und ausbauen zu können. ## Das wird wahrscheinlich auch der Weg der Zukunft sein. Darüber wird aber in der Rentenkommission noch weiter diskutiert werden. ## Wenn es aber etwas gibt, was wir klären müssen, dann ist das doch die Frage: Wollen wir in Zukunft wirklich auf die gesetzliche Rentenversicherung als wesentliche Säule unseres Rentensystems setzen, ja oder nein? ## Einen Weg zur Finanzierung werden wir in einem reichen Land wie Deutschland sicherlich finden, und zwar einen gerechten, wenn es nach der SPD geht. ## Letzter Satz. Wenn es also einen Gradmesser für die soziale Sicherheit in Deutschland gibt, dann ist das aus meiner Sicht eine gute Alterssicherung. Für eine gute Altersversorgung sorgen wir mit diesem Rentenpaket heute und jetzt. ## Vielen Dank. Somit könnten wir für dieses Protokoll die einzelnen Reden (aber zum Beispiel auch Zwischenfragen) von Abgeordneten gezielt auf deren Inhalte untersuchen. Wir können noch nicht die Zwischenrufe und den Applaus nach Abgeordneten bzw. Fraktionen auswerten. Dies wäre mit sogenannten regular experesions aber möglich. Wie wir alle aktuellen Protokolle auswerten, behandeln wir in Daten wir in Kapitel 3. Die beiden Funktionen speichern wir im Ordner “functions”. Literatur- und Quellverzeichnis "],
["data-02.html", "Kapitel 3 Datenerhebung Teil 2", " Kapitel 3 Datenerhebung Teil 2 Leider gibt es keine Möglichkeit, die XML-Protokolle des Deutschen Bundesatages gesammelt herunterzuladen. Zwar findet sich auf Open Data-Seite des Bundestags1 ein Verweis auf die Protkolle im XML-Format, allerdings lassen sie sich von dieser Seite nur mit mehreren Klicks installieren.$ source(&quot;functions/get_overview_df.R&quot;) source(&quot;functions/get_speeches_df.R&quot;) https://www.bundestag.de/service/opendata↩ "],
["literatur-und-quellverzeichnis.html", "Literatur- und Quellverzeichnis", " Literatur- und Quellverzeichnis "]
]
